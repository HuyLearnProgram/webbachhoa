import time
import os
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from webdriver_manager.chrome import ChromeDriverManager


class TC02_CartOpenTest:
    def __init__(self):
        chrome_options = Options()
        chrome_options.add_argument("--incognito")
        service = Service(ChromeDriverManager().install())
        self.driver = webdriver.Chrome(service=service, options=chrome_options)
        self.wait = WebDriverWait(self.driver, 10)
        self.actions = ActionChains(self.driver)
        self.driver.maximize_window()
        
        # L∆∞u tr·ªØ th√¥ng tin s·∫£n ph·∫©m ƒë√£ th√™m ƒë·ªÉ verification
        self.added_products = []
    
    def login(self, email, password):
        """ƒêƒÉng nh·∫≠p v√†o h·ªá th·ªëng"""
        try:
            # B∆∞·ªõc 1: ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn trang ch·ªß
            self.driver.get('http://localhost:5173/')
            time.sleep(1)
            
            # Click v√†o li√™n k·∫øt ƒëƒÉng nh·∫≠p
            login_link = self.wait.until(
                EC.element_to_be_clickable((By.XPATH, "//a[@href='/login' and contains(text(), 'ƒêƒÉng nh·∫≠p ho·∫∑c ƒëƒÉng k√Ω')]"))
            )
            login_link.click()
            time.sleep(2)
            
            # Nh·∫≠p th√¥ng tin ƒëƒÉng nh·∫≠p
            username_field = self.wait.until(EC.presence_of_element_located((By.NAME, "email")))
            password_field = self.driver.find_element(By.NAME, "password")
            
            username_field.clear()
            username_field.send_keys(email)
            password_field.clear()
            password_field.send_keys(password)
            time.sleep(2)
            
            # Click n√∫t ƒëƒÉng nh·∫≠p
            login_button = self.driver.find_element(By.XPATH, "//button[contains(@class, 'bg-main') and contains(text(), 'ƒêƒÉng nh·∫≠p')]")
            login_button.click()
            time.sleep(5)
            
            return True
        except Exception as e:
            return False
    
    def open_cart(self):
        """M·ªü gi·ªè h√†ng v√† ch·ªçn s·∫£n ph·∫©m"""
        try:
            # M·ªü gi·ªè h√†ng
            # KH·∫ÆC PH·ª§C: Khai b√°o initial_url tr∆∞·ªõc khi s·ª≠ d·ª•ng
            initial_url = self.driver.current_url
            cart_page = self.wait.until(
                EC.element_to_be_clickable((By.XPATH, "//div[contains(@class, 'cursor-pointer') and contains(., 's·∫£n ph·∫©m')]"))
            )
            cart_page.click()
            # ƒê·ª£i URL thay ƒë·ªïi (t·ªëi ƒëa 5 gi√¢y)
            WebDriverWait(self.driver, 5).until(
                lambda driver: driver.current_url != initial_url
            )
            
            # L·∫•y URL sau khi click
            current_url = self.driver.current_url
            print(f"‚úì URL sau khi click: {current_url}")
            
            # X√°c minh URL c√≥ ch·ª©a cart path
            if "http://localhost:5173/cart" in current_url:
                self.mark_test_status("PASS","ƒê√£ v√†o ƒë∆∞·ª£c trang gi·ªè h√†ng","Sufficient")    
                return True
            else:
                self.mark_test_status("FAIL","Kh√¥ng th·ªÉ v√†o trang gi·ªè h√†ng","Below Expectation") 
                return False
        except Exception as e:
            self.mark_test_status("FAIL", f"L·ªói m·ªü gi·ªè h√†ng v√† ch·ªçn s·∫£n ph·∫©m: {e}", level="Below Expectation")
            return False

    def verify_products_in_cart(self):
        """X√°c minh s·∫£n ph·∫©m trong gi·ªè h√†ng kh·ªõp v·ªõi s·∫£n ph·∫©m ƒë√£ th√™m"""
        try:
            
            # M·ªü gi·ªè h√†ng
            cart_icon = self.wait.until(
                EC.element_to_be_clickable((By.XPATH, "//div[contains(@class, 'cursor-pointer') and contains(., 's·∫£n ph·∫©m')]"))
            )
            cart_icon.click()
            time.sleep(3)
            
            # T√¨m s·∫£n ph·∫©m theo checkbox nh∆∞ng lo·∫°i tr·ª´ "Ch·ªçn t·∫•t c·∫£"
            cart_products = []
            
            try:
                # T√¨m checkbox nh∆∞ng lo·∫°i tr·ª´ checkbox "Ch·ªçn t·∫•t c·∫£"
                checkboxes = self.driver.find_elements(By.XPATH, "//input[@type='checkbox']")
                
                valid_checkboxes = []
                for checkbox in checkboxes:
                    try:
                        # L·∫•y parent container ƒë·ªÉ ki·ªÉm tra
                        parent = checkbox.find_element(By.XPATH, "./ancestor::div[1]")
                        parent_text = parent.text.strip().lower()
                        
                        # Lo·∫°i tr·ª´ checkbox "Ch·ªçn t·∫•t c·∫£"
                        if "ch·ªçn t·∫•t c·∫£" not in parent_text and "select all" not in parent_text:
                            valid_checkboxes.append(checkbox)
                    except:
                        valid_checkboxes.append(checkbox)  # Gi·ªØ l·∫°i n·∫øu kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c
                
                
                # L·∫•y parent container c·ªßa m·ªói checkbox h·ª£p l·ªá
                for i, checkbox in enumerate(valid_checkboxes):
                    try:
                        # T√¨m container cha ch·ª©a to√†n b·ªô th√¥ng tin s·∫£n ph·∫©m
                        product_container = checkbox.find_element(By.XPATH, "./ancestor::div[contains(@class, 'grid') or contains(@class, 'flex')][1]")
                        cart_products.append(product_container)
                    except:
                        continue
                        
            except:
                self.mark_test_status("FAIL","L·ªói khi x√°c nh·∫≠n s·∫£n ph·∫©m trong gi·ªè h√†ng", "Below Expectation")

            
            if not cart_products:
                return self.simple_cart_verification()
            
            # X√°c minh t·ª´ng s·∫£n ph·∫©m v·ªõi improved extraction
            verified_products = []
            for i, cart_product in enumerate(cart_products):
                try:
                    product_info = self.extract_product_info_from_div_improved(cart_product, i)
                    if product_info and self.is_valid_product_info_improved(product_info):
                        verified_products.append(product_info)

                except Exception as e:
                    self.mark_test_status("FAIL","L·ªói khi x√°c nh·∫≠n s·∫£n ph·∫©m trong gi·ªè h√†ng", "Below Expectation")

            
            if not verified_products:
                return self.simple_cart_verification()
            
            return True
            
        except Exception as e:
            return self.simple_cart_verification()

    def extract_product_info_from_div_improved(self, cart_product, index):
        """Improved extraction v·ªõi better parsing logic"""
        product_info = {'name': '', 'quantity': ''}
        
        try:
            # L·∫•y t·∫•t c·∫£ text t·ª´ container
            all_text = cart_product.text.strip()
            if not all_text:
                return None
            
            
            # Parse text ƒë·ªÉ t√¨m t√™n s·∫£n ph·∫©m v√† s·ªë l∆∞·ª£ng
            lines = [line.strip() for line in all_text.split('\n') if line.strip()]
            
            # T√¨m t√™n s·∫£n ph·∫©m - c·∫£i thi·ªán logic
            product_name = ""
            for line in lines:
                # T√™n s·∫£n ph·∫©m: d√≤ng d√†i, kh√¥ng ch·ª©a gi√° ti·ªÅn, kh√¥ng ph·∫£i UI elements
                if (len(line) > 15 and  # TƒÉng minimum length
                    not line.isdigit() and 
                    'ƒë' not in line and 
                    'C√≥ s·∫µn:' not in line and
                    'ch·ªçn t·∫•t c·∫£' not in line.lower() and
                    line not in ['-', '+'] and
                    not line.replace('.', '').replace(',', '').replace(' ', '').isdigit() and
                    not any(word in line.lower() for word in ['ch·ªçn', 't·∫•t c·∫£', 'select', 'all'])):
                    product_name = line
                    break
            
            # T√¨m s·ªë l∆∞·ª£ng - ∆∞u ti√™n input field
            quantity = "1"  # default
            try:
                # T√¨m input number field trong container n√†y
                quantity_input = cart_product.find_element(By.XPATH, ".//input[@type='number']")
                qty_value = quantity_input.get_attribute('value')
                if qty_value and qty_value.isdigit() and int(qty_value) > 0:
                    quantity = qty_value
            except:
                # Fallback: t√¨m trong text
                for line in lines:
                    if line.isdigit() and 1 <= int(line) <= 100:
                        quantity = line
                        break
            
            if product_name:  # Ch·ªâ return n·∫øu c√≥ t√™n s·∫£n ph·∫©m h·ª£p l·ªá
                product_info['name'] = product_name
                product_info['quantity'] = quantity
                return product_info
                
        except Exception as e:
            self.mark_test_status("FAIL","L·ªói khi tr√≠ch xu·∫•t th√¥ng tin s·∫£n ph·∫©m trong gi·ªè h√†ng", "Below Expectation")
        return None

    def is_valid_product_info_improved(self, product_info):
        """Improved validation v·ªõi stricter rules"""
        if not product_info or not product_info.get('name'):
            return False
        
        name = product_info['name'].strip()
        
        # Lo·∫°i b·ªè c√°c "s·∫£n ph·∫©m" kh√¥ng h·ª£p l·ªá
        invalid_patterns = [
            '-', '+', 'ƒë', '', 'ch·ªçn t·∫•t c·∫£', 'select all'
        ]
        
        # Ki·ªÉm tra t√™n s·∫£n ph·∫©m c√≥ h·ª£p l·ªá kh√¥ng
        if name.lower() in [p.lower() for p in invalid_patterns] or len(name) < 10:
            return False
        
        # Ki·ªÉm tra kh√¥ng ph·∫£i ch·ªâ l√† s·ªë ho·∫∑c k√Ω t·ª± ƒë·∫∑c bi·ªát
        if name.isdigit() or all(c in '-+' for c in name):
            return False
        
        # Ki·ªÉm tra kh√¥ng ch·ª©a c√°c t·ª´ kh√≥a UI
        ui_keywords = ['ch·ªçn', 't·∫•t c·∫£', 'select', 'all', 'checkbox']
        if any(keyword in name.lower() for keyword in ui_keywords):
            return False
        
        return True

    def simple_cart_verification(self):
        """Improved simple verification"""
        try:
            
            expected_count = len(self.added_products)
            
            # ƒê·∫øm checkbox s·∫£n ph·∫©m (lo·∫°i tr·ª´ "Ch·ªçn t·∫•t c·∫£")
            try:
                all_checkboxes = self.driver.find_elements(By.XPATH, "//input[@type='checkbox']")
                product_checkboxes = []
                
                for checkbox in all_checkboxes:
                    try:
                        parent = checkbox.find_element(By.XPATH, "./ancestor::div[1]")
                        parent_text = parent.text.strip().lower()
                        
                        if "ch·ªçn t·∫•t c·∫£" not in parent_text:
                            product_checkboxes.append(checkbox)
                    except:
                        product_checkboxes.append(checkbox)
                
                checkbox_count = len(product_checkboxes)
                
                if checkbox_count >= expected_count:
                    return True
            except:
                self.mark_test_status("FAIL","L·ªói khi x√°c nh·∫≠n gi·ªè h√†ng", "Below Expectation")
            
            return False
            
        except Exception as e:
            return False

    
    def run_tc03_test(self):
        """Ch·∫°y test case TC01 ho√†n ch·ªânh v·ªõi status marking chu·∫©n"""
        try:
            print("=== B·∫ÆT ƒê·∫¶U TEST CASE TC02: M·ªû TRANG GI·ªé H√ÄNG ===")
            
            # ƒêi·ªÅu ki·ªán ti√™n quy·∫øt: ƒêƒÉng nh·∫≠p
            if not self.login('huygiavu2003@gmail.com', '12345678'):
                self.mark_test_status("BLOCKED", "Kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p v√†o h·ªá th·ªëng", "Critical")
                return False
            
            if not self.open_cart():
                return False         
            
            if not self.verify_products_in_cart():
                self.mark_test_status("INCLUSIVE","Ki·ªÉm tra th√¥ng tin trong gi·ªè h√†ng kh√¥ng th√†nh c√¥ng","Medium")   
                return False       
            
            self.mark_test_status("PASS","ƒê√£ ki·ªÉm tra ƒë∆∞·ª£c th√¥ng tin trong gi·ªè","Sufficient")    
            
            return True        
        except Exception as e:
            self.mark_test_status("BLOCKED", f"L·ªói nghi√™m tr·ªçng trong qu√° tr√¨nh th·ª±c thi test: {str(e)}", "Critical")
            return False

    
    def cleanup(self):
        """D·ªçn d·∫πp v√† ƒë√≥ng browser"""
        if self.driver:
            self.driver.quit()
            print("‚úì ƒê√£ ƒë√≥ng browser")
    
    def mark_test_status(self, status, reason="", level=None):
        label = {
            "PASS": "[TEST PASSED]",
            "FAIL": "[TEST FAILED]",
            "BLOCKED": "[TEST BLOCKED]",
            "INCONCLUSIVE": "[TEST INCONCLUSIVE]"
        }
        level_label = f" (Level: {level})" if level else ""
        print(f"\n{label.get(status, '[UNKNOWN STATUS]')} - {reason}{level_label}\n")

# Ch·∫°y test
if __name__ == "__main__":
    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
    test = TC02_CartOpenTest()
    try:
        success = test.run_tc03_test()
        if success:
            print("\nüéØ K·∫æT QU·∫¢: TEST PASSED")
        else:
            print("\nüí• K·∫æT QU·∫¢: TEST FAILED")
    finally:
        test.cleanup()
